// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type NsxtIpsecVpnTunnelInitParameters struct {

	// PSK (pre-shared key) or CERTIFICATE (default -
	// PSK)
	// One of 'PSK' (default), 'CERTIFICATE'
	AuthenticationMode *string `json:"authenticationMode,omitempty" tf:"authentication_mode,omitempty"`

	// CA Certificate ID (can be handled by
	// vcd_library_certificate resource or datasource) Note authentication_mode must be set to
	// CERTIFICATE
	// Optional CA certificate ID to use for authentication
	CACertificateID *string `json:"caCertificateId,omitempty" tf:"ca_certificate_id,omitempty"`

	// Certificate ID (can be handled by vcd_library_certificate
	// resource or datasource). Note authentication_mode must be set to CERTIFICATE
	// Optional certificate ID to use for authentication
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// An optional description of the NSX-T IPsec VPN Tunnel
	// Description IP Sec VPN Tunnel
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the Edge Gateway (NSX-T only). Can be looked up using
	// vcd_nsxt_edgegateway data source
	// Edge gateway name in which IP Sec VPN configuration is located
	EdgeGatewayID *string `json:"edgeGatewayId,omitempty" tf:"edge_gateway_id,omitempty"`

	// Enables or disables IPsec VPN Tunnel (default true)
	// Enables or disables this configuration (default true)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.
	// IPv4 Address for the endpoint. This has to be a sub-allocated IP on the Edge Gateway.
	LocalIPAddress *string `json:"localIpAddress,omitempty" tf:"local_ip_address,omitempty"`

	// A set of local networks in CIDR format. At least one value required
	// Set of local networks in CIDR format. At least one value is required
	// +listType=set
	LocalNetworks []*string `json:"localNetworks,omitempty" tf:"local_networks,omitempty"`

	// Sets whether logging for the tunnel is enabled or not. (default - false)
	// Sets whether logging for the tunnel is enabled or not. (default - false)
	Logging *bool `json:"logging,omitempty" tf:"logging,omitempty"`

	// A name for NSX-T IPsec VPN Tunnel
	// Name of IP Sec VPN Tunnel
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of organization to use, optional if defined at provider level. Useful
	// when connected as sysadmin working across different organisations.
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations
	Org *string `json:"org,omitempty" tf:"org,omitempty"`

	// Pre-shared key for negotiation. Note the pre-shared key must be
	// the same on the other end of the IPSec VPN tunnel and authentication_mode must be PSK
	// Pre-Shared Key (PSK)
	PreSharedKeySecretRef v1.SecretKeySelector `json:"preSharedKeySecretRef" tf:"-"`

	// Remote ID uniquely identifies the peer site. If the remote ID is
	// not set, it will default to the remote IP address
	// Custom remote ID of the peer site. 'remote_ip_address' is used by default
	RemoteID *string `json:"remoteId,omitempty" tf:"remote_id,omitempty"`

	// Public IPv4 Address of the remote device terminating the VPN connection
	// Public IPv4 Address of the remote device terminating the VPN connection
	RemoteIPAddress *string `json:"remoteIpAddress,omitempty" tf:"remote_ip_address,omitempty"`

	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// +listType=set
	RemoteNetworks []*string `json:"remoteNetworks,omitempty" tf:"remote_networks,omitempty"`

	// a block allowing to
	// customize default security profile parameters
	// Security profile customization
	SecurityProfileCustomization []SecurityProfileCustomizationInitParameters `json:"securityProfileCustomization,omitempty" tf:"security_profile_customization,omitempty"`

	// The name of VDC to use, optional if defined at provider level
	Vdc *string `json:"vdc,omitempty" tf:"vdc,omitempty"`
}

type NsxtIpsecVpnTunnelObservation struct {

	// PSK (pre-shared key) or CERTIFICATE (default -
	// PSK)
	// One of 'PSK' (default), 'CERTIFICATE'
	AuthenticationMode *string `json:"authenticationMode,omitempty" tf:"authentication_mode,omitempty"`

	// CA Certificate ID (can be handled by
	// vcd_library_certificate resource or datasource) Note authentication_mode must be set to
	// CERTIFICATE
	// Optional CA certificate ID to use for authentication
	CACertificateID *string `json:"caCertificateId,omitempty" tf:"ca_certificate_id,omitempty"`

	// Certificate ID (can be handled by vcd_library_certificate
	// resource or datasource). Note authentication_mode must be set to CERTIFICATE
	// Optional certificate ID to use for authentication
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// An optional description of the NSX-T IPsec VPN Tunnel
	// Description IP Sec VPN Tunnel
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the Edge Gateway (NSX-T only). Can be looked up using
	// vcd_nsxt_edgegateway data source
	// Edge gateway name in which IP Sec VPN configuration is located
	EdgeGatewayID *string `json:"edgeGatewayId,omitempty" tf:"edge_gateway_id,omitempty"`

	// Enables or disables IPsec VPN Tunnel (default true)
	// Enables or disables this configuration (default true)
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Provides more details of failure if the IKE service is not UP
	// Provides more details of failure if the IKE service is not UP
	IkeFailReason *string `json:"ikeFailReason,omitempty" tf:"ike_fail_reason,omitempty"`

	// Status for the actual IKE Session for the given tunnel
	// Status for the actual IKE Session for the given tunnel
	IkeServiceStatus *string `json:"ikeServiceStatus,omitempty" tf:"ike_service_status,omitempty"`

	// IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.
	// IPv4 Address for the endpoint. This has to be a sub-allocated IP on the Edge Gateway.
	LocalIPAddress *string `json:"localIpAddress,omitempty" tf:"local_ip_address,omitempty"`

	// A set of local networks in CIDR format. At least one value required
	// Set of local networks in CIDR format. At least one value is required
	// +listType=set
	LocalNetworks []*string `json:"localNetworks,omitempty" tf:"local_networks,omitempty"`

	// Sets whether logging for the tunnel is enabled or not. (default - false)
	// Sets whether logging for the tunnel is enabled or not. (default - false)
	Logging *bool `json:"logging,omitempty" tf:"logging,omitempty"`

	// A name for NSX-T IPsec VPN Tunnel
	// Name of IP Sec VPN Tunnel
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of organization to use, optional if defined at provider level. Useful
	// when connected as sysadmin working across different organisations.
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations
	Org *string `json:"org,omitempty" tf:"org,omitempty"`

	// Remote ID uniquely identifies the peer site. If the remote ID is
	// not set, it will default to the remote IP address
	// Custom remote ID of the peer site. 'remote_ip_address' is used by default
	RemoteID *string `json:"remoteId,omitempty" tf:"remote_id,omitempty"`

	// Public IPv4 Address of the remote device terminating the VPN connection
	// Public IPv4 Address of the remote device terminating the VPN connection
	RemoteIPAddress *string `json:"remoteIpAddress,omitempty" tf:"remote_ip_address,omitempty"`

	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// +listType=set
	RemoteNetworks []*string `json:"remoteNetworks,omitempty" tf:"remote_networks,omitempty"`

	// DEFAULT for system provided configuration or CUSTOM if security_profile_customization is set
	// Security type which is use for IPsec VPN Tunnel. It will be 'DEFAULT' if nothing is customized and 'CUSTOM' if some changes are applied
	SecurityProfile *string `json:"securityProfile,omitempty" tf:"security_profile,omitempty"`

	// a block allowing to
	// customize default security profile parameters
	// Security profile customization
	SecurityProfileCustomization []SecurityProfileCustomizationObservation `json:"securityProfileCustomization,omitempty" tf:"security_profile_customization,omitempty"`

	// Overall IPsec VPN Tunnel Status
	// Overall IPsec VPN Tunnel Status
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// The name of VDC to use, optional if defined at provider level
	Vdc *string `json:"vdc,omitempty" tf:"vdc,omitempty"`
}

type NsxtIpsecVpnTunnelParameters struct {

	// PSK (pre-shared key) or CERTIFICATE (default -
	// PSK)
	// One of 'PSK' (default), 'CERTIFICATE'
	// +kubebuilder:validation:Optional
	AuthenticationMode *string `json:"authenticationMode,omitempty" tf:"authentication_mode,omitempty"`

	// CA Certificate ID (can be handled by
	// vcd_library_certificate resource or datasource) Note authentication_mode must be set to
	// CERTIFICATE
	// Optional CA certificate ID to use for authentication
	// +kubebuilder:validation:Optional
	CACertificateID *string `json:"caCertificateId,omitempty" tf:"ca_certificate_id,omitempty"`

	// Certificate ID (can be handled by vcd_library_certificate
	// resource or datasource). Note authentication_mode must be set to CERTIFICATE
	// Optional certificate ID to use for authentication
	// +kubebuilder:validation:Optional
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// An optional description of the NSX-T IPsec VPN Tunnel
	// Description IP Sec VPN Tunnel
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The ID of the Edge Gateway (NSX-T only). Can be looked up using
	// vcd_nsxt_edgegateway data source
	// Edge gateway name in which IP Sec VPN configuration is located
	// +kubebuilder:validation:Optional
	EdgeGatewayID *string `json:"edgeGatewayId,omitempty" tf:"edge_gateway_id,omitempty"`

	// Enables or disables IPsec VPN Tunnel (default true)
	// Enables or disables this configuration (default true)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// IPv4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway.
	// IPv4 Address for the endpoint. This has to be a sub-allocated IP on the Edge Gateway.
	// +kubebuilder:validation:Optional
	LocalIPAddress *string `json:"localIpAddress,omitempty" tf:"local_ip_address,omitempty"`

	// A set of local networks in CIDR format. At least one value required
	// Set of local networks in CIDR format. At least one value is required
	// +kubebuilder:validation:Optional
	// +listType=set
	LocalNetworks []*string `json:"localNetworks,omitempty" tf:"local_networks,omitempty"`

	// Sets whether logging for the tunnel is enabled or not. (default - false)
	// Sets whether logging for the tunnel is enabled or not. (default - false)
	// +kubebuilder:validation:Optional
	Logging *bool `json:"logging,omitempty" tf:"logging,omitempty"`

	// A name for NSX-T IPsec VPN Tunnel
	// Name of IP Sec VPN Tunnel
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name of organization to use, optional if defined at provider level. Useful
	// when connected as sysadmin working across different organisations.
	// The name of organization to use, optional if defined at provider level. Useful when connected as sysadmin working across different organizations
	// +kubebuilder:validation:Optional
	Org *string `json:"org,omitempty" tf:"org,omitempty"`

	// Pre-shared key for negotiation. Note the pre-shared key must be
	// the same on the other end of the IPSec VPN tunnel and authentication_mode must be PSK
	// Pre-Shared Key (PSK)
	// +kubebuilder:validation:Optional
	PreSharedKeySecretRef v1.SecretKeySelector `json:"preSharedKeySecretRef" tf:"-"`

	// Remote ID uniquely identifies the peer site. If the remote ID is
	// not set, it will default to the remote IP address
	// Custom remote ID of the peer site. 'remote_ip_address' is used by default
	// +kubebuilder:validation:Optional
	RemoteID *string `json:"remoteId,omitempty" tf:"remote_id,omitempty"`

	// Public IPv4 Address of the remote device terminating the VPN connection
	// Public IPv4 Address of the remote device terminating the VPN connection
	// +kubebuilder:validation:Optional
	RemoteIPAddress *string `json:"remoteIpAddress,omitempty" tf:"remote_ip_address,omitempty"`

	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// Set of remote networks in CIDR format. Leaving it empty is interpreted as 0.0.0.0/0
	// +kubebuilder:validation:Optional
	// +listType=set
	RemoteNetworks []*string `json:"remoteNetworks,omitempty" tf:"remote_networks,omitempty"`

	// a block allowing to
	// customize default security profile parameters
	// Security profile customization
	// +kubebuilder:validation:Optional
	SecurityProfileCustomization []SecurityProfileCustomizationParameters `json:"securityProfileCustomization,omitempty" tf:"security_profile_customization,omitempty"`

	// The name of VDC to use, optional if defined at provider level
	// +kubebuilder:validation:Optional
	Vdc *string `json:"vdc,omitempty" tf:"vdc,omitempty"`
}

type SecurityProfileCustomizationInitParameters struct {

	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the
	// maximum is 60 seconds
	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
	DpdProbeInternal *float64 `json:"dpdProbeInternal,omitempty" tf:"dpd_probe_internal,omitempty"`

	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of
	// GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +listType=set
	IkeDhGroups []*string `json:"ikeDhGroups,omitempty" tf:"ike_dh_groups,omitempty"`

	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1,
	// SHA2_256, SHA2_384, SHA2_512
	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	IkeDigestAlgorithms []*string `json:"ikeDigestAlgorithms,omitempty" tf:"ike_digest_algorithms,omitempty"`

	// Encryption algorithms One of AES_128, AES_256, AES_GCM_128, AES_GCM_192,
	// AES_GCM_256
	// Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	IkeEncryptionAlgorithms []*string `json:"ikeEncryptionAlgorithms,omitempty" tf:"ike_encryption_algorithms,omitempty"`

	// Security association lifetime in seconds. It is number of seconds before the IPsec
	// tunnel needs to reestablish
	// Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
	IkeSaLifetime *float64 `json:"ikeSaLifetime,omitempty" tf:"ike_sa_lifetime,omitempty"`

	// One of IKE_V1, IKE_V2, IKE_FLEX
	// IKE version one of IKE_V1, IKE_V2, IKE_FLEX
	IkeVersion *string `json:"ikeVersion,omitempty" tf:"ike_version,omitempty"`

	// Policy for handling defragmentation bit. One of COPY, CLEAR
	// Policy for handling defragmentation bit. One of COPY, CLEAR
	TunnelDfPolicy *string `json:"tunnelDfPolicy,omitempty" tf:"tunnel_df_policy,omitempty"`

	// Diffie-Hellman groups to be used is PFS is enabled.
	// One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +listType=set
	TunnelDhGroups []*string `json:"tunnelDhGroups,omitempty" tf:"tunnel_dh_groups,omitempty"`

	// Digest algorithms to be used for message digest.
	// One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	TunnelDigestAlgorithms []*string `json:"tunnelDigestAlgorithms,omitempty" tf:"tunnel_digest_algorithms,omitempty"`

	// Encryption algorithms to use in IPSec tunnel establishment.
	// One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128,
	// NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// +listType=set
	TunnelEncryptionAlgorithms []*string `json:"tunnelEncryptionAlgorithms,omitempty" tf:"tunnel_encryption_algorithms,omitempty"`

	// PFS (Perfect Forward Secrecy) enabled or disabled.
	// Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
	TunnelPfsEnabled *bool `json:"tunnelPfsEnabled,omitempty" tf:"tunnel_pfs_enabled,omitempty"`

	// Security Association life time in seconds
	// Security Association life time (in seconds)
	TunnelSaLifetime *float64 `json:"tunnelSaLifetime,omitempty" tf:"tunnel_sa_lifetime,omitempty"`
}

type SecurityProfileCustomizationObservation struct {

	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the
	// maximum is 60 seconds
	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
	DpdProbeInternal *float64 `json:"dpdProbeInternal,omitempty" tf:"dpd_probe_internal,omitempty"`

	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of
	// GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +listType=set
	IkeDhGroups []*string `json:"ikeDhGroups,omitempty" tf:"ike_dh_groups,omitempty"`

	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1,
	// SHA2_256, SHA2_384, SHA2_512
	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	IkeDigestAlgorithms []*string `json:"ikeDigestAlgorithms,omitempty" tf:"ike_digest_algorithms,omitempty"`

	// Encryption algorithms One of AES_128, AES_256, AES_GCM_128, AES_GCM_192,
	// AES_GCM_256
	// Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	IkeEncryptionAlgorithms []*string `json:"ikeEncryptionAlgorithms,omitempty" tf:"ike_encryption_algorithms,omitempty"`

	// Security association lifetime in seconds. It is number of seconds before the IPsec
	// tunnel needs to reestablish
	// Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
	IkeSaLifetime *float64 `json:"ikeSaLifetime,omitempty" tf:"ike_sa_lifetime,omitempty"`

	// One of IKE_V1, IKE_V2, IKE_FLEX
	// IKE version one of IKE_V1, IKE_V2, IKE_FLEX
	IkeVersion *string `json:"ikeVersion,omitempty" tf:"ike_version,omitempty"`

	// Policy for handling defragmentation bit. One of COPY, CLEAR
	// Policy for handling defragmentation bit. One of COPY, CLEAR
	TunnelDfPolicy *string `json:"tunnelDfPolicy,omitempty" tf:"tunnel_df_policy,omitempty"`

	// Diffie-Hellman groups to be used is PFS is enabled.
	// One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +listType=set
	TunnelDhGroups []*string `json:"tunnelDhGroups,omitempty" tf:"tunnel_dh_groups,omitempty"`

	// Digest algorithms to be used for message digest.
	// One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +listType=set
	TunnelDigestAlgorithms []*string `json:"tunnelDigestAlgorithms,omitempty" tf:"tunnel_digest_algorithms,omitempty"`

	// Encryption algorithms to use in IPSec tunnel establishment.
	// One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128,
	// NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// +listType=set
	TunnelEncryptionAlgorithms []*string `json:"tunnelEncryptionAlgorithms,omitempty" tf:"tunnel_encryption_algorithms,omitempty"`

	// PFS (Perfect Forward Secrecy) enabled or disabled.
	// Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
	TunnelPfsEnabled *bool `json:"tunnelPfsEnabled,omitempty" tf:"tunnel_pfs_enabled,omitempty"`

	// Security Association life time in seconds
	// Security Association life time (in seconds)
	TunnelSaLifetime *float64 `json:"tunnelSaLifetime,omitempty" tf:"tunnel_sa_lifetime,omitempty"`
}

type SecurityProfileCustomizationParameters struct {

	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the
	// maximum is 60 seconds
	// Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
	// +kubebuilder:validation:Optional
	DpdProbeInternal *float64 `json:"dpdProbeInternal,omitempty" tf:"dpd_probe_internal,omitempty"`

	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of
	// GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +kubebuilder:validation:Optional
	// +listType=set
	IkeDhGroups []*string `json:"ikeDhGroups" tf:"ike_dh_groups,omitempty"`

	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1,
	// SHA2_256, SHA2_384, SHA2_512
	// Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +kubebuilder:validation:Optional
	// +listType=set
	IkeDigestAlgorithms []*string `json:"ikeDigestAlgorithms,omitempty" tf:"ike_digest_algorithms,omitempty"`

	// Encryption algorithms One of AES_128, AES_256, AES_GCM_128, AES_GCM_192,
	// AES_GCM_256
	// Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +kubebuilder:validation:Optional
	// +listType=set
	IkeEncryptionAlgorithms []*string `json:"ikeEncryptionAlgorithms" tf:"ike_encryption_algorithms,omitempty"`

	// Security association lifetime in seconds. It is number of seconds before the IPsec
	// tunnel needs to reestablish
	// Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
	// +kubebuilder:validation:Optional
	IkeSaLifetime *float64 `json:"ikeSaLifetime,omitempty" tf:"ike_sa_lifetime,omitempty"`

	// One of IKE_V1, IKE_V2, IKE_FLEX
	// IKE version one of IKE_V1, IKE_V2, IKE_FLEX
	// +kubebuilder:validation:Optional
	IkeVersion *string `json:"ikeVersion" tf:"ike_version,omitempty"`

	// Policy for handling defragmentation bit. One of COPY, CLEAR
	// Policy for handling defragmentation bit. One of COPY, CLEAR
	// +kubebuilder:validation:Optional
	TunnelDfPolicy *string `json:"tunnelDfPolicy,omitempty" tf:"tunnel_df_policy,omitempty"`

	// Diffie-Hellman groups to be used is PFS is enabled.
	// One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
	// +kubebuilder:validation:Optional
	// +listType=set
	TunnelDhGroups []*string `json:"tunnelDhGroups" tf:"tunnel_dh_groups,omitempty"`

	// Digest algorithms to be used for message digest.
	// One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
	// +kubebuilder:validation:Optional
	// +listType=set
	TunnelDigestAlgorithms []*string `json:"tunnelDigestAlgorithms,omitempty" tf:"tunnel_digest_algorithms,omitempty"`

	// Encryption algorithms to use in IPSec tunnel establishment.
	// One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128,
	// NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
	// +kubebuilder:validation:Optional
	// +listType=set
	TunnelEncryptionAlgorithms []*string `json:"tunnelEncryptionAlgorithms" tf:"tunnel_encryption_algorithms,omitempty"`

	// PFS (Perfect Forward Secrecy) enabled or disabled.
	// Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
	// +kubebuilder:validation:Optional
	TunnelPfsEnabled *bool `json:"tunnelPfsEnabled,omitempty" tf:"tunnel_pfs_enabled,omitempty"`

	// Security Association life time in seconds
	// Security Association life time (in seconds)
	// +kubebuilder:validation:Optional
	TunnelSaLifetime *float64 `json:"tunnelSaLifetime,omitempty" tf:"tunnel_sa_lifetime,omitempty"`
}

// NsxtIpsecVpnTunnelSpec defines the desired state of NsxtIpsecVpnTunnel
type NsxtIpsecVpnTunnelSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NsxtIpsecVpnTunnelParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider NsxtIpsecVpnTunnelInitParameters `json:"initProvider,omitempty"`
}

// NsxtIpsecVpnTunnelStatus defines the observed state of NsxtIpsecVpnTunnel.
type NsxtIpsecVpnTunnelStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NsxtIpsecVpnTunnelObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// NsxtIpsecVpnTunnel is the Schema for the NsxtIpsecVpnTunnels API. Provides a resource to manage NSX-T IPsec VPN Tunnel. You can configure site-to-site connectivity between an NSX-T Data Center Edge Gateway and remote sites. The remote sites must use NSX-T Data Center, have third-party hardware routers, or VPN gateways that support IPSec.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vcd}
type NsxtIpsecVpnTunnel struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.edgeGatewayId) || (has(self.initProvider) && has(self.initProvider.edgeGatewayId))",message="spec.forProvider.edgeGatewayId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.localIpAddress) || (has(self.initProvider) && has(self.initProvider.localIpAddress))",message="spec.forProvider.localIpAddress is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.localNetworks) || (has(self.initProvider) && has(self.initProvider.localNetworks))",message="spec.forProvider.localNetworks is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.preSharedKeySecretRef)",message="spec.forProvider.preSharedKeySecretRef is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.remoteIpAddress) || (has(self.initProvider) && has(self.initProvider.remoteIpAddress))",message="spec.forProvider.remoteIpAddress is a required parameter"
	Spec   NsxtIpsecVpnTunnelSpec   `json:"spec"`
	Status NsxtIpsecVpnTunnelStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NsxtIpsecVpnTunnelList contains a list of NsxtIpsecVpnTunnels
type NsxtIpsecVpnTunnelList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NsxtIpsecVpnTunnel `json:"items"`
}

// Repository type metadata.
var (
	NsxtIpsecVpnTunnel_Kind             = "NsxtIpsecVpnTunnel"
	NsxtIpsecVpnTunnel_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NsxtIpsecVpnTunnel_Kind}.String()
	NsxtIpsecVpnTunnel_KindAPIVersion   = NsxtIpsecVpnTunnel_Kind + "." + CRDGroupVersion.String()
	NsxtIpsecVpnTunnel_GroupVersionKind = CRDGroupVersion.WithKind(NsxtIpsecVpnTunnel_Kind)
)

func init() {
	SchemeBuilder.Register(&NsxtIpsecVpnTunnel{}, &NsxtIpsecVpnTunnelList{})
}
