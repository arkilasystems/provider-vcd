// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IPPrefixInitParameters struct {

	// default Quota for this particular Prefix defined in
	// prefix field. A Quota of -1 means there is no cap to the number of
	// IP Prefixes that can be allocated. A Quota of 0 means that the IP Prefixes cannot be allocated.
	// Floating IP quota
	DefaultQuota *string `json:"defaultQuota,omitempty" tf:"default_quota,omitempty"`

	// IP block definition as detail below
	// One or more prefixes
	Prefix []PrefixInitParameters `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IPPrefixObservation struct {

	// default Quota for this particular Prefix defined in
	// prefix field. A Quota of -1 means there is no cap to the number of
	// IP Prefixes that can be allocated. A Quota of 0 means that the IP Prefixes cannot be allocated.
	// Floating IP quota
	DefaultQuota *string `json:"defaultQuota,omitempty" tf:"default_quota,omitempty"`

	// IP block definition as detail below
	// One or more prefixes
	Prefix []PrefixObservation `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IPPrefixParameters struct {

	// default Quota for this particular Prefix defined in
	// prefix field. A Quota of -1 means there is no cap to the number of
	// IP Prefixes that can be allocated. A Quota of 0 means that the IP Prefixes cannot be allocated.
	// Floating IP quota
	// +kubebuilder:validation:Optional
	DefaultQuota *string `json:"defaultQuota,omitempty" tf:"default_quota,omitempty"`

	// IP block definition as detail below
	// One or more prefixes
	// +kubebuilder:validation:Optional
	Prefix []PrefixParameters `json:"prefix" tf:"prefix,omitempty"`
}

type IPRangeInitParameters struct {

	// - End IP address of a range
	// End address of the IP range
	EndAddress *string `json:"endAddress,omitempty" tf:"end_address,omitempty"`

	// - Start IP address of a range
	// Start address of the IP range
	StartAddress *string `json:"startAddress,omitempty" tf:"start_address,omitempty"`
}

type IPRangeObservation struct {

	// - End IP address of a range
	// End address of the IP range
	EndAddress *string `json:"endAddress,omitempty" tf:"end_address,omitempty"`

	// ID of IP Range
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// - Start IP address of a range
	// Start address of the IP range
	StartAddress *string `json:"startAddress,omitempty" tf:"start_address,omitempty"`
}

type IPRangeParameters struct {

	// - End IP address of a range
	// End address of the IP range
	// +kubebuilder:validation:Optional
	EndAddress *string `json:"endAddress" tf:"end_address,omitempty"`

	// - Start IP address of a range
	// Start address of the IP range
	// +kubebuilder:validation:Optional
	StartAddress *string `json:"startAddress" tf:"start_address,omitempty"`
}

type IpSpaceInitParameters struct {

	// Defines whether
	// default firewall rule creation should be enabled
	// Flag exposing whether default firewall rule creation should be enabled (VCD 10.5.0+)
	DefaultFirewallRuleCreationEnabled *bool `json:"defaultFirewallRuleCreationEnabled,omitempty" tf:"default_firewall_rule_creation_enabled,omitempty"`

	// Defines whether NO SNAT
	// rule creation should be enabled
	// Flag whether NO SNAT rule creation should be enabled (VCD 10.5.0+)
	DefaultNoSnatRuleCreationEnabled *bool `json:"defaultNoSnatRuleCreationEnabled,omitempty" tf:"default_no_snat_rule_creation_enabled,omitempty"`

	// Defines whether SNAT rule
	// creation should be enabled
	// Flag whether SNAT rule creation should be enabled (VCD 10.5.0+)
	DefaultSnatRuleCreationEnabled *bool `json:"defaultSnatRuleCreationEnabled,omitempty" tf:"default_snat_rule_creation_enabled,omitempty"`

	// Description of IP Space
	// Description of IP space
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The external scope defines the total span of IP addresses to which the IP
	// space has access, for example the internet or a WAN.
	// External scope in CIDR format
	ExternalScope *string `json:"externalScope,omitempty" tf:"external_scope,omitempty"`

	// One or more IP prefixes (blocks) ip_prefix
	// One or more IP prefixes within internal scope
	IPPrefix []IPPrefixInitParameters `json:"ipPrefix,omitempty" tf:"ip_prefix,omitempty"`

	// One or more ip_range for floating IP address
	// allocation. (Floating IP addresses are just IP addresses taken from the defined range)
	// One or more IP ranges for floating IP allocation
	IPRange []IPRangeInitParameters `json:"ipRange,omitempty" tf:"ip_range,omitempty"`

	// If you entered at least one IP Range
	// (ip_range), enter a number of floating IP addresses to allocate individually.
	// -1 is unlimited, while 0 means that no IPs can be allocated.
	// IP ranges quota. '-1' - unlimited, '0' - no quota
	IPRangeQuota *string `json:"ipRangeQuota,omitempty" tf:"ip_range_quota,omitempty"`

	// The internal scope of an IP space is a list of CIDR notations that
	// defines the exact span of IP addresses in which all ranges and blocks must be contained in.
	// A set of internal scope IPs in CIDR format
	// +listType=set
	InternalScope []*string `json:"internalScope,omitempty" tf:"internal_scope,omitempty"`

	// A name for IP Space
	// Name of IP space
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for PRIVATE type
	// Org ID for 'SHARED' IP spaces
	OrgID *string `json:"orgId,omitempty" tf:"org_id,omitempty"`

	// Toggle on the route advertisement option to
	// enable advertising networks with IP prefixes from this IP space (default false)
	// Flag whether route advertisement should be enabled
	RouteAdvertisementEnabled *bool `json:"routeAdvertisementEnabled,omitempty" tf:"route_advertisement_enabled,omitempty"`

	// One of PUBLIC, SHARED_SERVICES, PRIVATE
	// Type of IP space
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type IpSpaceObservation struct {

	// Defines whether
	// default firewall rule creation should be enabled
	// Flag exposing whether default firewall rule creation should be enabled (VCD 10.5.0+)
	DefaultFirewallRuleCreationEnabled *bool `json:"defaultFirewallRuleCreationEnabled,omitempty" tf:"default_firewall_rule_creation_enabled,omitempty"`

	// Defines whether NO SNAT
	// rule creation should be enabled
	// Flag whether NO SNAT rule creation should be enabled (VCD 10.5.0+)
	DefaultNoSnatRuleCreationEnabled *bool `json:"defaultNoSnatRuleCreationEnabled,omitempty" tf:"default_no_snat_rule_creation_enabled,omitempty"`

	// Defines whether SNAT rule
	// creation should be enabled
	// Flag whether SNAT rule creation should be enabled (VCD 10.5.0+)
	DefaultSnatRuleCreationEnabled *bool `json:"defaultSnatRuleCreationEnabled,omitempty" tf:"default_snat_rule_creation_enabled,omitempty"`

	// Description of IP Space
	// Description of IP space
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The external scope defines the total span of IP addresses to which the IP
	// space has access, for example the internet or a WAN.
	// External scope in CIDR format
	ExternalScope *string `json:"externalScope,omitempty" tf:"external_scope,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// One or more IP prefixes (blocks) ip_prefix
	// One or more IP prefixes within internal scope
	IPPrefix []IPPrefixObservation `json:"ipPrefix,omitempty" tf:"ip_prefix,omitempty"`

	// One or more ip_range for floating IP address
	// allocation. (Floating IP addresses are just IP addresses taken from the defined range)
	// One or more IP ranges for floating IP allocation
	IPRange []IPRangeObservation `json:"ipRange,omitempty" tf:"ip_range,omitempty"`

	// If you entered at least one IP Range
	// (ip_range), enter a number of floating IP addresses to allocate individually.
	// -1 is unlimited, while 0 means that no IPs can be allocated.
	// IP ranges quota. '-1' - unlimited, '0' - no quota
	IPRangeQuota *string `json:"ipRangeQuota,omitempty" tf:"ip_range_quota,omitempty"`

	// The internal scope of an IP space is a list of CIDR notations that
	// defines the exact span of IP addresses in which all ranges and blocks must be contained in.
	// A set of internal scope IPs in CIDR format
	// +listType=set
	InternalScope []*string `json:"internalScope,omitempty" tf:"internal_scope,omitempty"`

	// A name for IP Space
	// Name of IP space
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for PRIVATE type
	// Org ID for 'SHARED' IP spaces
	OrgID *string `json:"orgId,omitempty" tf:"org_id,omitempty"`

	// Toggle on the route advertisement option to
	// enable advertising networks with IP prefixes from this IP space (default false)
	// Flag whether route advertisement should be enabled
	RouteAdvertisementEnabled *bool `json:"routeAdvertisementEnabled,omitempty" tf:"route_advertisement_enabled,omitempty"`

	// One of PUBLIC, SHARED_SERVICES, PRIVATE
	// Type of IP space
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type IpSpaceParameters struct {

	// Defines whether
	// default firewall rule creation should be enabled
	// Flag exposing whether default firewall rule creation should be enabled (VCD 10.5.0+)
	// +kubebuilder:validation:Optional
	DefaultFirewallRuleCreationEnabled *bool `json:"defaultFirewallRuleCreationEnabled,omitempty" tf:"default_firewall_rule_creation_enabled,omitempty"`

	// Defines whether NO SNAT
	// rule creation should be enabled
	// Flag whether NO SNAT rule creation should be enabled (VCD 10.5.0+)
	// +kubebuilder:validation:Optional
	DefaultNoSnatRuleCreationEnabled *bool `json:"defaultNoSnatRuleCreationEnabled,omitempty" tf:"default_no_snat_rule_creation_enabled,omitempty"`

	// Defines whether SNAT rule
	// creation should be enabled
	// Flag whether SNAT rule creation should be enabled (VCD 10.5.0+)
	// +kubebuilder:validation:Optional
	DefaultSnatRuleCreationEnabled *bool `json:"defaultSnatRuleCreationEnabled,omitempty" tf:"default_snat_rule_creation_enabled,omitempty"`

	// Description of IP Space
	// Description of IP space
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The external scope defines the total span of IP addresses to which the IP
	// space has access, for example the internet or a WAN.
	// External scope in CIDR format
	// +kubebuilder:validation:Optional
	ExternalScope *string `json:"externalScope,omitempty" tf:"external_scope,omitempty"`

	// One or more IP prefixes (blocks) ip_prefix
	// One or more IP prefixes within internal scope
	// +kubebuilder:validation:Optional
	IPPrefix []IPPrefixParameters `json:"ipPrefix,omitempty" tf:"ip_prefix,omitempty"`

	// One or more ip_range for floating IP address
	// allocation. (Floating IP addresses are just IP addresses taken from the defined range)
	// One or more IP ranges for floating IP allocation
	// +kubebuilder:validation:Optional
	IPRange []IPRangeParameters `json:"ipRange,omitempty" tf:"ip_range,omitempty"`

	// If you entered at least one IP Range
	// (ip_range), enter a number of floating IP addresses to allocate individually.
	// -1 is unlimited, while 0 means that no IPs can be allocated.
	// IP ranges quota. '-1' - unlimited, '0' - no quota
	// +kubebuilder:validation:Optional
	IPRangeQuota *string `json:"ipRangeQuota,omitempty" tf:"ip_range_quota,omitempty"`

	// The internal scope of an IP space is a list of CIDR notations that
	// defines the exact span of IP addresses in which all ranges and blocks must be contained in.
	// A set of internal scope IPs in CIDR format
	// +kubebuilder:validation:Optional
	// +listType=set
	InternalScope []*string `json:"internalScope,omitempty" tf:"internal_scope,omitempty"`

	// A name for IP Space
	// Name of IP space
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Required for PRIVATE type
	// Org ID for 'SHARED' IP spaces
	// +kubebuilder:validation:Optional
	OrgID *string `json:"orgId,omitempty" tf:"org_id,omitempty"`

	// Toggle on the route advertisement option to
	// enable advertising networks with IP prefixes from this IP space (default false)
	// Flag whether route advertisement should be enabled
	// +kubebuilder:validation:Optional
	RouteAdvertisementEnabled *bool `json:"routeAdvertisementEnabled,omitempty" tf:"route_advertisement_enabled,omitempty"`

	// One of PUBLIC, SHARED_SERVICES, PRIVATE
	// Type of IP space
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type PrefixInitParameters struct {

	// - First IP of the prefix
	// First IP
	FirstIP *string `json:"firstIp,omitempty" tf:"first_ip,omitempty"`

	// - Number of prefixes
	// Number of prefixes to define
	PrefixCount *string `json:"prefixCount,omitempty" tf:"prefix_count,omitempty"`

	// Prefix length
	// Prefix length
	PrefixLength *string `json:"prefixLength,omitempty" tf:"prefix_length,omitempty"`
}

type PrefixObservation struct {

	// - First IP of the prefix
	// First IP
	FirstIP *string `json:"firstIp,omitempty" tf:"first_ip,omitempty"`

	// ID of IP Prefix
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// - Number of prefixes
	// Number of prefixes to define
	PrefixCount *string `json:"prefixCount,omitempty" tf:"prefix_count,omitempty"`

	// Prefix length
	// Prefix length
	PrefixLength *string `json:"prefixLength,omitempty" tf:"prefix_length,omitempty"`
}

type PrefixParameters struct {

	// - First IP of the prefix
	// First IP
	// +kubebuilder:validation:Optional
	FirstIP *string `json:"firstIp" tf:"first_ip,omitempty"`

	// - Number of prefixes
	// Number of prefixes to define
	// +kubebuilder:validation:Optional
	PrefixCount *string `json:"prefixCount" tf:"prefix_count,omitempty"`

	// Prefix length
	// Prefix length
	// +kubebuilder:validation:Optional
	PrefixLength *string `json:"prefixLength" tf:"prefix_length,omitempty"`
}

// IpSpaceSpec defines the desired state of IpSpace
type IpSpaceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     IpSpaceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider IpSpaceInitParameters `json:"initProvider,omitempty"`
}

// IpSpaceStatus defines the observed state of IpSpace.
type IpSpaceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        IpSpaceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// IpSpace is the Schema for the IpSpaces API. Provides a resource to manage IP Spaces for IP address management needs. IP Spaces provide structured approach to allocating public and private IP addresses by preventing the use of overlapping IP addresses across organizations and organization VDCs.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vcd}
type IpSpace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.internalScope) || (has(self.initProvider) && has(self.initProvider.internalScope))",message="spec.forProvider.internalScope is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",message="spec.forProvider.type is a required parameter"
	Spec   IpSpaceSpec   `json:"spec"`
	Status IpSpaceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IpSpaceList contains a list of IpSpaces
type IpSpaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IpSpace `json:"items"`
}

// Repository type metadata.
var (
	IpSpace_Kind             = "IpSpace"
	IpSpace_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: IpSpace_Kind}.String()
	IpSpace_KindAPIVersion   = IpSpace_Kind + "." + CRDGroupVersion.String()
	IpSpace_GroupVersionKind = CRDGroupVersion.WithKind(IpSpace_Kind)
)

func init() {
	SchemeBuilder.Register(&IpSpace{}, &IpSpaceList{})
}
